//a library app, mostly for the draw command, which allows to import these shape-drawing functions into your own app.
//Arguments for each are to be given as a singleton list, for ease of use. This is with the exception of fill_flat, with
//the assumption that it is unlikely to be used outside of internal calls, but it is still available to be called if necessary.
//Make sure you read the arguments and input them in the correct order, or it will mess up.
//these functions return a set of all the positions in the shape, given the parameters, without repeating a position.
//This way, you can efficiently iterate over the positions once having generated them. See draw_beta.sc for an example.


draw_sphere(args)->(
    [centre, radius, hollow] = args;
    positions = {};
    [cx,cy,cz]=centre;
    for(range(-90, 90, 45/radius),
        cpitch = cos(_);
        spitch = sin(_);
        for(range(0, 180, 45/radius),
            cyaw = cos(_)*cpitch*radius;
            syaw = sin(_)*cpitch*radius;
            if(hollow,
                positions += [cx+cyaw,cy+spitch*radius,cz+syaw];
                positions += [cx+cos(_+180)*cpitch*radius,cy+spitch*radius,cz+sin(_+180)*cpitch*radius],
                for(range(-syaw,syaw+1),
                    positions += [cx+cyaw*cpitch,cy+spitch*radius,cz+_]
                )
            )
        )
    );
    return(positions)
);

draw_diamond(args)->(
    [pos, radius] = args;
    positions = {};
    c_for(r=0, r<radius, r+=1,
        y = r-radius+1;
        c_for(x=-r,x<=r,x+=1,
            z=r-abs(x);
            positions += [pos:0+x, pos:1 +y, pos:2+z];
            positions += [pos:0+x, pos:1 +y, pos:2-z];
            positions += [pos:0+x, pos:1 -y, pos:2+z];
            positions += [pos:0+x, pos:1 -y, pos:2-z];
        )
    );
    return(positions)
);

draw_filled_diamond(args)->(
    [pos, radius] = args;
    positions = {};
    for(diamond(pos,radius,radius),
        positions += pos(_)
    );
    return(positions)
);

draw_pyramid(args)->(
    [pos, radius, height, pointing, orientation, fill_type, is_square] = args;//todo change to hollow boolean arg
    positions = {};
    hollow = fill_type=='hollow';
    pointup = pointing=='up';
    for(range(height),
        r = if(pointup, radius * ( 1- _ / height) -1, radius * _ / height);
        positions += fill_flat(pos, _, r, is_square, orientation, if((pointup&&_==0)||(!pointup && _==height-1),false,hollow))//Always close bottom off
    );
    return(positions)
);

draw_prism(args)->(
    [pos, rad, height, orientation, fill_type, is_square]=args;//todo change to hollow boolean arg
    positions = {};
    hollow = fill_type =='hollow';
    radius = rad+0.5;
    for(range(height),
        positions += fill_flat(pos, _, radius, is_square, orientation, if(_==0 || _==height-1,false,hollow))//Always close ends off
    );
    return(positions)
);

fill_flat(pos, offset, dr, rectangle, orientation, hollow)->(
    r = floor(dr);
    drsq = dr^2;
    positions = {};
    if(orientation=='x',
        scan(pos,0,-r,-r,
            if((!hollow && (rectangle || _y^2 + _z^2 <= drsq))||//if not hollow, vry simple
                (hollow && ((rectangle && (abs(_y) == r || abs(_z) ==r)) || //If hollow and it's a rectangle
                (!rectangle && (_y^2 + _z^2 <= drsq && (abs(_y)+1)^ 2 + (abs(_z)+1)^2 >= drsq)))),//If hollow and not rectangle
                positions += [_x+offset,_y,_z]
            )
        ),
    orientation == 'y',
        scan(pos,-r,0,-r,
            if((!hollow && (rectangle || _x^2 + _z^2 <= drsq))||//if not hollow, vry simple
                (hollow && ((rectangle && (abs(_x) == r || abs(_z) ==r)) || //If hollow and it's a rectangle
                (!rectangle && (_x^2 + _z^2 <= drsq && (abs(_x)+1)^ 2 + (abs(_z)+1)^2 >= drsq)))),//If hollow and not rectangle
                positions += [_x,_y+offset,_z]
            )
        ),
    orientation == 'z',
        scan(pos,-r,-r,0,
            if((!hollow && (rectangle || _y^2 + _x^2 <= drsq))||//if not hollow, vry simple
                (hollow && ((rectangle && (abs(_y) == r || abs(_x) ==r)) || //If hollow and it's a rectangle
                (!rectangle && (_y^2 + _x^2 <= drsq && (abs(_y)+1)^ 2 + (abs(_x)+1)^2 >= drsq)))),//If hollow and not rectangle
                positions += [_x,_y,_z+offset]
            )
        )
    );
    return(positions)
);
