package carpet.mixins;

import carpet.CarpetSettings;
import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
import net.minecraft.structure.StructureStart;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.world.IWorld;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import net.minecraft.world.gen.chunk.ChunkGeneratorConfig;
import net.minecraft.world.gen.feature.StructureFeature;
import org.spongepowered.asm.mixin.Mixin;

import java.util.Random;

@Mixin(StructureFeature.class)
public class StructureFeatureMixin
{
    //problem is that is seems that now chunks deal with its portion of the strucuture
    //on its own.

    public boolean plopAnywhere(IWorld world, BlockPos pos)
    {
        return plopAnywhere(world, pos, world.getChunkManager().getChunkGenerator());
    }
    public boolean plopAnywhere(IWorld world, BlockPos pos, ChunkGenerator<? extends ChunkGeneratorConfig> generator)
    {
        CarpetSettings.skipGenerationChecks = true;
        try
        {
            Random rand = new Random(world.getRandom().nextInt());
            int j = pos.getX() >> 4;
            int k = pos.getZ() >> 4;
            long chId = ChunkPos.toLong(j, k);
            StructureStart structurestart = forceStructureStart(world, generator, rand, chId);
            if (structurestart == null || structurestart == StructureStart.DEFAULT)
            {
                CarpetSettings.skipGenerationChecks = false;
                return false;
            }
            generator.ge   getStructurePositionToReferenceMap(this).computeIfAbsent(chId, (x) -> new LongOpenHashSet()).add(chId);
            world.getChunkManager().getChunkOrPrimer(j, k, true).addStructureReference(this.getStructureName(), chId);
            MutableBoundingBox box = structurestart.getBoundingBox();
            structurestart.generateStructure(
                    world,
                    rand,
                    new MutableBoundingBox(
                            pos.getX() - this.getSize()*16,
                            pos.getZ() - this.getSize()*16,
                            pos.getX() + (this.getSize()+1)*16,
                            pos.getZ() + (1+this.getSize())*16),
                    new ChunkPos(j, k)
            );
            structurestart.notifyPostProcessAt(new ChunkPos(j, k));

            int i = this.getSize();
            for (int k1 = j - i; k1 <= j + i; ++k1)
            {
                for (int l1 = k - i; l1 <= k + i; ++l1)
                {
                    if (k1 == j && l1 == k) continue;
                    long nbchkid = ChunkPos.toLong(k1, l1);
                    if (box.intersectsWith(k1<<4, l1<<4, (k1<<4) + 15, (l1<<4) + 15))
                    {
                        generator.getStructurePositionToReferenceMap(this).computeIfAbsent(nbchkid, (__) -> new LongOpenHashSet()).add(chId);
                        world.getChunkManager().getChunkOrPrimer(k1, l1, true).addStructureReference(this.getStructureName(), chId);
                        structurestart.notifyPostProcessAt(new ChunkPos(k1, l1));
                    }
                }
            }
        }
        catch (Exception ignored)
        {
            CarpetSettings.LOG.error("Unknown Exception while plopping structure: "+ignored);
            ignored.printStackTrace();
            CarpetSettings.skipGenerationChecks = false;
            return false;
        }
        CarpetSettings.skipGenerationChecks = false;
        return true;
    }

    private StructureStart forceStructureStart(IWorld worldIn, ChunkGenerator <? extends ChunkGeneratorConfig > generator, Random rand, long packedChunkPos)
    {

        Long2ObjectMap<StructureStart> long2objectmap = generator.getStructureReferenceToStartMap(this);
        StructureStart structurestart = long2objectmap.get(packedChunkPos);

        if (structurestart != null)
        {
            return structurestart; // structure already exist, will skip
        }
        ChunkPos chunkpos = new ChunkPos(packedChunkPos);
        IChunk ichunk = worldIn.getChunkManager().getChunkOrPrimer(chunkpos.x, chunkpos.z, false);

        if (ichunk != null)
        {
            structurestart = ichunk.getStructureStart(this.getStructureName());

            if (structurestart != null)
            {
                long2objectmap.put(packedChunkPos, structurestart);
                return structurestart;
            }
        }

        StructureStart structurestart1 = this.makeStart(worldIn, generator, rand, chunkpos.x, chunkpos.z);
        structurestart = structurestart1.isValid() ? structurestart1 : NO_STRUCTURE;

        if (structurestart.isValid())
        {
            worldIn.getChunkManager().getChunkOrPrimer(chunkpos.x, chunkpos.z, true).putStructureStart(this.getStructureName(), structurestart);
        }

        long2objectmap.put(packedChunkPos, structurestart);
        return structurestart;
    }
}
